<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FRoneX Livonia Danger Map</title>

  <meta name="description" content="Interactive Livonia danger map (Wardens / Blackwood Rangers / Ironfang Raiders) with layer toggles." />
  <meta property="og:title" content="FRoneX Livonia Danger Map" />
  <meta property="og:description" content="Interactive map: danger zones, patrol routes, POI, labels. Toggle layers." />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; background:#0b0f14; }
    #map { height: 100%; width: 100%; }

    .legend {
      background: rgba(0,0,0,0.75);
      color: #fff;
      padding: 12px 14px;
      border-radius: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 14px;
      line-height: 1.35;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      max-width: 360px;
    }
    .legend h3 { margin: 0 0 10px; font-size: 15px; }
    .row { display: flex; align-items: center; gap: 10px; margin: 7px 0; }
    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; }
    .muted { opacity: 0.85; font-size: 12px; margin-top: 10px; }

    .leaflet-control-layers {
      border-radius: 14px !important;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .leaflet-control-layers-expanded {
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(10px);
    }

    /* Labels */
    .city-label {
      font-weight: 900;
      font-size: 14px;
      color: #fff;
      text-shadow: 0 2px 8px rgba(0,0,0,0.85);
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0;
      margin: 0;
    }
    .city-label.low { color: #b9ffcc; }
    .city-label.med { color: #ffd28a; }
    .city-label.ext { color: #ffb0b0; }

    /* POI labels */
    .poi-label {
      font-weight: 800;
      font-size: 12px;
      color: #e8f1ff;
      text-shadow: 0 2px 8px rgba(0,0,0,0.9);
      background: rgba(0,0,0,0.25);
      border-radius: 8px;
      padding: 2px 6px;
      border: 1px solid rgba(255,255,255,0.15);
      backdrop-filter: blur(8px);
    }
  </style>
</head>

<body>
<div id="map"></div>

<script>
  /**
   * Tiles: /tiles/{z}/{x}/{y}.jpg
   * Generator output = XYZ (y –≤–Ω–∏–∑) => tms: false
   */

  const MAP_SIZE = 18000;     // px
  const TILE_SIZE = 256;

  // maxNativeZoom = —Ä–µ–∞–ª—å–Ω–∏–π –º–∞–∫—Å–∏–º—É–º —É tiles
  const MAX_NATIVE_ZOOM = 5;
  const MAX_ZOOM = 5;
  const MIN_ZOOM = 0;

  const COLORS = {
    WARDENS: "#2ecc71",
    RANGERS: "#ff9f1a",
    RAIDERS: "#ff3b30",
    POI: "#67b7ff",
    ROUTE: "#ffffff"
  };

  // ===== MAP INIT =====
  const map = L.map('map', {
    crs: L.CRS.Simple,
    minZoom: MIN_ZOOM,
    maxZoom: MAX_ZOOM,
    zoomSnap: 0.25,
    zoomControl: true,
    preferCanvas: true,
    attributionControl: false
  });

  // ‚úÖ Correct bounds using unproject
  const southWest = map.unproject([0, MAP_SIZE], MAX_NATIVE_ZOOM);
  const northEast = map.unproject([MAP_SIZE, 0], MAX_NATIVE_ZOOM);
  const bounds = L.latLngBounds(southWest, northEast);

  // ‚úÖ Base tiles as BASE LAYER
  const baseTiles = L.tileLayer("./tiles/{z}/{x}/{y}.jpg", {
    tileSize: TILE_SIZE,
    minZoom: MIN_ZOOM,
    maxZoom: MAX_ZOOM,
    maxNativeZoom: MAX_NATIVE_ZOOM,
    noWrap: true,
    bounds: bounds,
    tms: false,
    keepBuffer: 6,
    updateWhenIdle: true,
    updateWhenZooming: false
  }).addTo(map);

  map.setMaxBounds(bounds.pad(0.06));
  map.fitBounds(bounds);

  // Keep inside bounds (prevents gray background)
  map.on("drag", () => map.panInsideBounds(bounds, { animate: false }));
  map.on("zoomend", () => map.panInsideBounds(bounds, { animate: false }));

  // ===== HELPERS =====
  function pxToLatLng(x, z){ return map.unproject([x, z], MAX_NATIVE_ZOOM); }

  function pxRadiusToMapRadius(centerX, centerZ, radiusPx){
    const c = pxToLatLng(centerX, centerZ);
    const edge = pxToLatLng(centerX + radiusPx, centerZ);
    return c.distanceTo(edge);
  }

  function dangerLabel(tier) {
    if (tier === "LOW") return "LOW danger";
    if (tier === "MEDIUM") return "MEDIUM danger";
    return "EXTREME danger";
  }

  function labelClass(tier){
    if (tier==="LOW") return "city-label low";
    if (tier==="MEDIUM") return "city-label med";
    return "city-label ext";
  }

  function popupHTML(z) {
    return `
      <div style="font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; min-width: 240px;">
        <div style="font-size: 16px; font-weight: 1000; margin-bottom: 6px;">${z.name}</div>
        <div><b>Faction:</b> ${z.faction}</div>
        <div><b>Threat:</b> ${dangerLabel(z.tier)}</div>
        <div><b>AI:</b> ${z.ai}</div>
        <div><b>Zone:</b> ${z.radius} m</div>
        <div><b>Coords:</b> X${z.x} Z${z.z}</div>
      </div>
    `;
  }

  // ===== LAYERS =====
  const layerLabels  = L.layerGroup();
  const layerFactions = L.layerGroup();
  const layerRoutes  = L.layerGroup();
  const layerPOI     = L.layerGroup();
  const layerHeat    = L.layerGroup();
  const layerGrid    = L.layerGroup();

  // ===== GRID =====
  for (let i = 0; i <= MAP_SIZE; i += 2000) {
    const a1 = map.unproject([i, 0], MAX_NATIVE_ZOOM);
    const a2 = map.unproject([i, MAP_SIZE], MAX_NATIVE_ZOOM);
    const b1 = map.unproject([0, i], MAX_NATIVE_ZOOM);
    const b2 = map.unproject([MAP_SIZE, i], MAX_NATIVE_ZOOM);

    L.polyline([a1, a2], { weight: 1, opacity: 0.12 }).addTo(layerGrid);
    L.polyline([b1, b2], { weight: 1, opacity: 0.12 }).addTo(layerGrid);
  }

  // ===== DATA (AUTO IMPORT) =====

// Load Expansion AI JSON directly from same folder (GitHub Pages)
async function loadJSON(path){
  const res = await fetch(path, { cache: 'no-store' });
  if (!res.ok) throw new Error(`${path} HTTP ${res.status}`);
  return await res.json();
}

// Convert faction name to color
function factionColor(f){
  const s = String(f||'').toLowerCase();
  if (s.includes('warden')) return COLORS.WARDENS;
  if (s.includes('ranger')) return COLORS.RANGERS;
  if (s.includes('ironfang') || s.includes('raider')) return COLORS.RAIDERS;
  return '#9aa4b2';
}

function factionTier(f){
  const s = String(f||'').toLowerCase();
  if (s.includes('warden')) return 'LOW';
  if (s.includes('ranger')) return 'MEDIUM';
  if (s.includes('ironfang') || s.includes('raider')) return 'EXTREME';
  return 'MEDIUM';
}

function patrolCenterMeters(waypoints){
  // Average X/Z
  let sx=0, sz=0, n=0;
  for (const w of waypoints||[]){
    if (!w || w.length < 3) continue;
    sx += Number(w[0]);
    sz += Number(w[2]);
    n++;
  }
  if (!n) return null;
  return { x: sx/n, z: sz/n };
}

// ===== RENDERING (AUTO IMPORT) =====

// Convert DayZ meters -> pixel -> latlng
const WORLD_SIZE = 12800;            // Livonia meters (0..12800)
const SCALE = MAP_SIZE / WORLD_SIZE; // px per meter

function dzToLatLng(xMeters, zMeters){
  const px = xMeters * SCALE;
  const pz = zMeters * SCALE;
  return map.unproject([px, pz], MAX_NATIVE_ZOOM);
}

function metersToRadius(centerXM, centerZM, radiusMeters){
  const c = dzToLatLng(centerXM, centerZM);
  const e = dzToLatLng(centerXM + radiusMeters, centerZM);
  return c.distanceTo(e);
}

function makeCityLabel(name, tier, x, z){
  const ll = dzToLatLng(x, z);
  L.marker(ll, { interactive: false, opacity: 0.95 })
    .bindTooltip(name, { permanent: true, direction: "center", className: labelClass(tier) })
    .addTo(layerLabels);
}

function renderPatrol(p){
  const name = p.Name || 'Patrol';
  const faction = p.Faction || '';
  const color = factionColor(faction);
  const tier = factionTier(faction);

  const wps = Array.isArray(p.Waypoints) ? p.Waypoints : [];
  const pts = wps
    .filter(w => Array.isArray(w) && w.length >= 3)
    .map(w => dzToLatLng(Number(w[0]), Number(w[2])));

  if (pts.length < 2) return;

  // Route polyline
  L.polyline(pts, {
    color: color,
    weight: 3,
    opacity: 0.85,
    dashArray: (tier === 'EXTREME') ? '8 10' : null
  }).addTo(layerRoutes).bindTooltip(name);

  // Waypoint markers
  pts.forEach((ll, idx) => {
    L.circleMarker(ll, {
      radius: idx === 0 ? 7 : 5,
      weight: 2,
      color: color,
      fillColor: color,
      fillOpacity: 1
    }).addTo(layerRoutes)
      .bindPopup(`<b>${name}</b><br/>${faction || ''}<br/>WP ${idx+1}`);
  });

  // City center marker based on patrol average
  const c = patrolCenterMeters(wps);
  if (c){
    const llc = dzToLatLng(c.x, c.z);

    // Big danger zone circle (x3 as requested)
    const baseRadius = (p.MaxDistRadius && p.MaxDistRadius > 0) ? Number(p.MaxDistRadius) : 500;
    const radius = baseRadius * 3;

    L.circle(llc, {
      radius: metersToRadius(c.x, c.z, radius),
      color: color,
      weight: 2,
      opacity: 0.9,
      fillColor: color,
      fillOpacity: 0.18
    }).addTo(layerFactions);

    L.circleMarker(llc, {
      radius: 7,
      color: color,
      fillColor: color,
      fillOpacity: 1,
      weight: 2
    }).addTo(layerFactions)
      .bindPopup(`<b>${name}</b><br/><b>Faction:</b> ${faction}<br/><b>AI:</b> ${p.NumberOfAI ?? ''}`);

    // Heat
    const intensity = (tier === "LOW") ? 0.9 : (tier === "MEDIUM" ? 1.25 : 1.7);
    const steps = 7;
    for (let i=1; i<=steps; i++){
      const k=i/steps;
      const rMeters = radius * (0.3 + 1.1*k);
      const opacity = (0.16 * intensity) * (1.0 - k*0.85);
      L.circle(llc, {
        radius: metersToRadius(c.x, c.z, rMeters),
        color: color,
        weight: 0,
        opacity: 0,
        fillColor: color,
        fillOpacity: Math.max(0, opacity)
      }).addTo(layerHeat);
    }

    // Label (city name from patrol prefix)
    const city = String(name).split('_')[0] || name;
    makeCityLabel(city, tier, c.x, c.z);
  }
}

function renderRoamingLocation(loc){
  const name = loc.Name || 'Location';
  const pos = loc.Position || [];
  if (!Array.isArray(pos) || pos.length < 3) return;
  const x = Number(pos[0]);
  const z = Number(pos[2]);
  const r = Number(loc.Radius || 100);

  const ll = dzToLatLng(x, z);

  // POI circle
  L.circle(ll, {
    radius: metersToRadius(x, z, r),
    color: COLORS.POI,
    weight: 1,
    opacity: 0.8,
    fillColor: COLORS.POI,
    fillOpacity: 0.08
  }).addTo(layerPOI);

  L.circleMarker(ll, {
    radius: 5,
    weight: 2,
    color: COLORS.POI,
    fillColor: COLORS.POI,
    fillOpacity: 1
  }).addTo(layerPOI)
    .bindPopup(`<b>${name}</b><br/>Radius: ${r}m<br/>X${x.toFixed(1)} Z${z.toFixed(1)}`);
}

// MAIN: import JSON + render
(async function(){
  try {
    const [loc, pat] = await Promise.all([
      loadJSON('./AILocationSettings.json'),
      loadJSON('./AIPatrolSettings.json')
    ]);

    // Patrols => zones + routes + labels
    const patrols = Array.isArray(pat.Patrols) ? pat.Patrols : [];
    patrols.forEach(renderPatrol);

    // RoamingLocations => POI layer
    const roaming = Array.isArray(loc.RoamingLocations) ? loc.RoamingLocations : [];
    roaming.filter(r => r && r.Enabled !== 0).forEach(renderRoamingLocation);

  } catch (e) {
    console.error('Import failed:', e);
    alert('ERROR: –ù–µ –≤–¥–∞–ª–æ—Å—å –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ AILocationSettings.json / AIPatrolSettings.json.\n–ü–µ—Ä–µ–≤—ñ—Ä —â–æ —Ñ–∞–π–ª–∏ –ª–µ–∂–∞—Ç—å –ø–æ—Ä—É—á –∑ HTML –Ω–∞ GitHub Pages.');
  }
})();
// ===== DEFAULT ON =====
  layerFactions.addTo(map);
  layerLabels.addTo(map);
  layerRoutes.addTo(map);
  layerPOI.addTo(map);
  layerGrid.addTo(map);
  // heat OFF by default (–º–æ–∂–Ω–∞ –≤–∫–ª—é—á–∏—Ç–∏ —É –º–µ–Ω—é)

  // ===== LAYER CONTROL =====
  const baseLayers = {
    "üó∫Ô∏è Livonia Map (tiles)": baseTiles
  };

  const overlays = {
    "üè∑Ô∏è Labels (cities)": layerLabels,
    "‚öîÔ∏è Factions / Zones": layerFactions,
    "üß≠ Routes (patrols)": layerRoutes,
    "üè• POI (Police/Med)": layerPOI,
    "üî• Heatmap": layerHeat,
    "üìê Grid": layerGrid
  };

  L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);

  // ===== LEGEND =====
  const legend = L.control({position: 'bottomleft'});
  legend.onAdd = function() {
    const div = L.DomUtil.create('div', 'legend');
    div.innerHTML = `
      <h3>FRoneX ‚Äì Livonia Danger Map</h3>
      <div class="row"><span class="dot" style="background:${COLORS.WARDENS}"></span><div><b>Livonian Wardens</b><br/>LOW threat</div></div>
      <div class="row"><span class="dot" style="background:${COLORS.RANGERS}"></span><div><b>Blackwood Rangers</b><br/>MEDIUM threat</div></div>
      <div class="row"><span class="dot" style="background:${COLORS.RAIDERS}"></span><div><b>Ironfang Raiders</b><br/>EXTREME threat</div></div>
      <div class="muted">‚úÖ Full 18K map fixed: bounds via unproject + maxBounds. No gray borders.</div>
    `;
    return div;
  };
  legend.addTo(map);
</script>
</body>
</html>
